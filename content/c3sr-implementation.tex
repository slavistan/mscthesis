\def\ApiHubMlf{http://eigen.tuxfamily.org/index.php?title=Main_Page}

\chapter{Implementation Details}

  In order to asses the viability of the concepts introduced in the previous chapter a prototype software library has
  been implemented. This chapter explains noteworthy design choices and implementation details and takes note where
  alternative options exist.

  \section{Generation of C3SR Matrices From Matrices in CSR Representation}

    The C3SR-format can be understood as a refinement of the CSR-format's basic ideas for sparse banded matrices derived
    from structured grids. Naturally, the CSR-format has been chosen as a landing pad for the creation of matrix objects
    in C3SR-format. Eigen \cite{eigen:website} is a general purpose C++ template library for linear algebra. Its sparse
    matrices can be stored in a CSR-format variant from which all C3SR-matrices used for this project are generated.

    The CSR-format does not specify any order in which a row's nonzeros' information ought to appear in data. In order
    to easily recognize two rows with equal values or equal structure the rows' segments within the value and the
    column-index arrays are sorted in ascending fashion with respect to the rows' common column indices. This task can
    be fully parallelized across multiple threads and greatly improves the performance of the construction of C3SR
    objects. Once a definite order among a row's nonzeros has been established the nonzeros' values and column indices
    are compressed separately to create the matrix's representation in C3SR-format.

    Firstly, the C3SR-format's value array V and its index-pointer array VS are populated by removing duplicate segments
    from the CSR-format's value array which pertain to different rows. For the description of the algorithm it is
    condusive to conceive of the nonzero values corresponding to a matrix row as a word made from individual letters.
    The task may then be expressed in a simple manner: Given an array of letters comprising an unknown number of
    different words of possibly different lengths, whose first letters are pointed by the elements of a separate
    index-pointer array, remove duplicate words and adjust the index-pointers accordingly. The order in which the words
    appear in the compressed output array shall adhere to the original order in which they show up in the input array.
    This increases the likelyhood that data which relates to contiguous matrix rows which cannot be compressed appears
    contiguously in the arrays which is condusive to spatial data locality for matrix-vector multiplication.

    The compression is achieved in four steps: First, the data is sorted lexicographically by words. Then duplicate
    words and their index-pointers are discarded. Then, using the unique words, the original order of these words is
    restored by sorting by the words' original indices. Utilizing the lengths of the words a sorted look-up table of
    their starting positions is created. Finally, in order to build the new index-array the original input data is
    traversed once again and the individual words' starting indices relative to the new, compressed word array are
    quickly retrieved from the look-up table through binary searches. Figure \ref{fig:c3sr-compression-scheme} outlines
    the individual steps. Take note that the lexicographical ordering is well-defined for words whose "letters" are
    numerical values, as is the case for the values and column-indices of a matrix in CSR-format.

    \begin{figure}[H]
      \centering
      \captionsetup{width=0.9\columnwidth}
      \input{./assets/c3sr-compression-scheme.tex}
      \toccaption{Schematic diagram of the C3SR compression scheme.}{Starting out at a dense array of letters segmented
        into distinct words by a secondary index-pointer array (I), the data structure is sorted lexicographically by
        the words and, among identical words, by the words' indices (II). Duplicate words and their index-pointers are
        removed (III) and the remaining data structure is sorted by the indices which restores the original order in
        which the words appeared retaining only unique words. Knowing the words' lengths a sorted look-up table for the
        index-pointers is set up (IV). Finally, the new index-pointer array is built by traversing the original data
        structure's words and retrieving the corresponding new index from the look-up table (V). The diagram shows the
        first $5$ words, $3$ of which are unique (A, B, C) indicated by different field widths. The lexicographical
        order of all words is B < A < C < $\ldots$. Index-pointers always point the first letter in a word and their
        values are indicated by arrows to the words they point. The drawn arrows end in the central area of the word
        they point for the sake of recognizability.}
      \label{fig:c3sr-compression-scheme}
    \end{figure}

    In order to compress the CSR-matrix's structural information first the peg indices JP are retrieved, i.e. the
    column-indices of each row's first nonzero element. As the CSR-matrix's nonzeros have been previously sorted the peg
    index of a row is necessarily the very first entry in the row's segment within the column-index array.

    Using the previously acquired peg indices every element in a row's segment within the CSR-matrix's column-index
    array is reduced by the corresponding row's peg index. This uncompressed array of column-index patterns is then
    subjected to the same compression scheme described above for the value array. This populates the C3SR-format's J and
    JS arrays. Finally, the row-size array RS is populated by computing the adjacent difference across the CSR-format's
    row-pointer array, an operation which constitutes the exclusive scan's inverse operation used to construct the
    row-pointer array for a CSR-matrix from the number of nonzeros in each row.

  \section{Run-Length Encoding}

    \Todo{Inhalt}

    The storage scheme introduced above may be further refined by run-length encoding the index-pointer arrays VS and
    JS aswell as JP and RS, respectively. Sparse banded matrices derived from large structured grids contain slices of
    fully diagonal structure at regular intervals corresponding to nodes with contiguous indices in the inner volume
    of the grid where the adjacency pattern is not perturbed by the grid's boundaries. The matrix in Figure
    \ref{fig:laplacian-example} exhibits these slices consisting of 3 contiguous rows ($x$-dimension of the grid is 5
    minus 2 outer nodes). The size of these slices grows linearly with the grid's extent in the direction of
    increasing node index.

    The pattern index-pointers in JS increase linearly ...

  \section{Matrix-Vector Multiplication}

    \subsection{Parallelization}

      As opposed to the CSR-format spreading the arithmetic workload of matrix-vector multiplications evenly among
      software threads is less trivial. The CSR-format's row-pointer array contains the scan of the number of non-zeros
      up to a row's respective index and as the number of non-zeros in a row is roughly proportional to its arithmetic
      workload ($n_\text{nnz}$ multiplications and $(n_\text{nnz} - 1)$ additions per $n_\text{nnz}$ non-zeros)
      spreading the workload evenly among $n_T$ theads is trivial requiring the row-pointer array to be partitioned such
      that the partitions' values span evenly sized ranges of indices. As the row-pointer array is sorted in ascending
      fashion this can be achieved very efficiently by $(n_T - 1)$ binary searches.

    \Todo{Bei SIMD Scheme II}

       Thus, in contrast to the previous multiplication scheme no gather instruction is required to compute a
       matrix-vector product which significantly reduces the operation's comprexity resulting in faster execution times.

    \Todo{Generell zu SIMD Schemes}

      All of the arithmetic schemes described above can be extended to vector registers of arbitrary length and are thus
      theoretically able to scale with additional hardware capabilities. Of course, in order to utilize the
      above-mentioned computation schemes, a preliminary analysis of the matrix's structure has to be performed in order
      to determine the segments which can facilitate vectorized arithmetic. Due to the storage scheme of the C3SR
      format, this can be done very cheaply since if a matrix segment has a diagonal or uniform structure all of the
      rows exhibit the same pattern and hence the same values in JS. For uniformly structured segments all peg indices
      are identical, while for a diagonally structured segment the peg indices are consecutive integers. Additionally,
      if the rows' values are identical for the case of a diagonal structure the rows' index-pointers VS are also
      identical.
